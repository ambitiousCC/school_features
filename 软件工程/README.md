# 软件工程

## 软件、软件工程、软件危机

### 软件
软件 = 程序 + 数据 + 文档
1. 程序 = 算法 + 数据结构；是按照事先设计的功能和性能要求执行的指令序列
2. 数据：程序初始化数据、测试数据、研发数据和维护数据等
3. 文档：与程序开发、维护和使用有关的图文材料

### 软件危机
软件开发和维护的过程中遇到的一系列严重的问题
比如：开发成本和进度的估计不准确、用户对软件的交付不满意、质量不保证等

具体解释：落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发和维护过程中出现的一系列严重问题的现象。

### 软件工程
定义：将计算机科学、管理科学等理论运用于指导软件开发与维护的一门交叉学科。
研究内容
* 目标：如何经济的、高质量的开发与维护一个软件系统
* 方面：过程、方法、工具

* 详细定义：将系统化、规范化、可度量的方法应用于软件开发、运行和维护过程，即将工程化应用于软件中的方法的研究。从管理和技术两方面研究如何更好地开发和维护计算机软件的一门新兴学科。

* 补充定义：
1. 软件工程是一项建模活动
2. 软件工程是一项解决问题的工程活动
3. 软件工程是一项受软件工程原理指导的活动

## 软件过程和问题定义

### 软件生命周期
软件产品从**考虑其概念到开始交付使用，直至最终退役为止**的整个过程

1. 软件定义时期：确定软件系统要做什么，又称为系统分析，包括：
* 问题定义：定义解决的问题
* 可行性分析：能否完成
* 需求分析：用户需求

> 需求开发过程
> 1. 需求获取：访谈、问卷调查、专题讨论会等手段获取用户需求
> 2. 需求建模：清晰、简明方式将需求分析获得的信息记录下来得到的一个逻辑模型
> 3. 需求规格说明：用户和开发人员都充分了解用户需求之后，将共同的理解以规范化的形式准确地表达，形成说明书
> 4. 需求评审：需求交付设计之前，对需求规格说明书进行彻底的检查和修改将
> 需求管理：软件开发过程中会出现需求的提出和更改
> 1. 需求变更控制：需求变更就要对变更影响和成本进行分析，通过用户方和开发方组成的变更控制委员会来决策以规范和控制需求变更
> 2. 需求版本控制：保证需求文档那个中记录和反映所有的需求变化呢
> 3. 需求跟踪：维护需求的可跟踪的信息
> 4. 需求状态跟踪：跟踪需求的状态

2. 软件开发阶段：具体设计和实现软件
* 设计：如何实现目标系统【概要设计】->具体实现系统【详细设计】
* 编码：写代码和单元测试
* 测试：集成测试以及验收测试等并产生测试报告
3. 运行维护：根据软件中运行的问题对其修改从而能够持续的满足用户的需求
维护：软件维护（改正性维护，适应性维护，完善性维护，防御性维护）

### 软件过程模型
定义：又称软件开发模型和软件工程范型；是对**软件开发全部过程的抽象，对软件全部开发过程中涉及的活动或者任务、以及活动之间的关系的抽象，过程、活动和任务的结构框架**。
作用：明确规定了要完成的活动、任务和开发策略；**告诉人们应该遵循什么过程开发软件系统**；提供里程碑和进度表；开发提供框架和方法

> 模型注重理解！

#### 传统模型
1. 瀑布模型：
* 各个过程相互衔接，呈线性，相互依赖，维护的时候变成循环了；自上而下（注意过程中可以循环），相互衔接的固定次序。
优点：
* 方便，容易理解。

缺点：
* 过于理想通过文档的完成情况评估项目完成进度时往往会产生错误的结论
* 大量文档大大增加软件开发的工作量
* 需要等待一定时间才能够得到一份软件的最初版本

2. 原型模型：
* 先获取用户的需求造一个小型软件系统原型，然后听取用户的意见修改，然后再听取用户的修改，准确的确定用户的需求；
* 主要是用户不停地参与，容易维护；

优点：
* 用户参与，尽早揭露软件中可能存在的风险以及不确定因素，尤其是关于用户需求一致性方面的风险
* 开发过程中培训同步，对用户友好

缺点：
* 不经过系统分析并对系统进行整体划分，直接使用原型系统进行模拟比较困难
* 对于大规模的程序，原型难以构造
* 对于某些系统，无法应用
* 文档容易被忽视，给后期的原型的改进和维护造成了困难

注意使用的策略：
* 废弃策略：不采用原来的系统
* 追加策略：不断地扩充和修改

3. 增量模型：让客户逐步把需求提出来
* 搭积木，完成一部分就向用户展示一部分，不断地搭积木；
* 需求发生变化较大的场景，开发人员没头绪的场景，项目风险高的场景，用户可以参与到整个项目的开发过程中；
* 增量模型过大会暴露和瀑布模型一样的缺点：卡在某个地方动不了。对开发人员的能力要求比较高：需要将需求转化为对应合适的增量。
4. 螺旋模型：
* 瀑布模型+原型模型+增量模型+风险分析，有了风险分析，开发管理人员就能够及时调整管理决策降低风险，支持用户的动态需求变化；
* 主要适用于**需求不明确**的大型项目；
* 需要有经验丰富的风险评估专家，如果每次迭代的效率低下，就会增加迭代的次数，延长开发并推迟提交时间。
5. 喷泉模型：
* 考虑一下喷泉，上去了又可以下来，这个也是同理，各个阶段没有特定的次序要求，可以交互进行。
* 可以在其他的开发阶段补充弥补其他阶段的漏洞，可以提高效率，节省时间；高效迭代无间隙；
* 过程比较混乱，不方便管理。

#### 现代模型
1. 基于构件的开发模型：集成；软件复用，开发速度快，质量高，适用于系统可以模块的地方（有共性的情况）；比较复杂，有的构件需要购买还不能修改，就可能不能满足用户的需求，也不能完全控制开发系统的演化，项目划分的好坏直接影响项目结果的好坏。
构件/组件：系统中模块化的，可以更换的部分，能够实现特定功能，可以实现封装，暴露的一组接口。
2. 统一过程模型
3. 敏捷开发

### 可行性研究
研究这个软件项目是否值得去开发，需要从项目的技术可行性、经济可行性、操作可行性和社会可行性进行研究和分析，并最终做出该项目是否具有可行性的结论

## 结构化设计


### 模块化
定义：解决一个复杂问题时自顶向下把软件划分成为若干个模块的过程，每个模块完成一个子功能。
模块：组成目标系统逻辑模型和物理模型的基本单位，一般是一组程序语句：可以通过名字访问的过程、函数、子程序或宏调用。
特点：可以组合分解和更换
基本属性：接口、功能、逻辑、状态

模块化作用
1. 结构清晰
2. 可靠性高
3. 可修改性
4. 降低复杂度、便于分工

### 模块独立性
定义：每个模块只涉及软件要求的具体的子功能，而和软件系统中的其他的模块的接口是简单的。

#### 模块独立性的两个准则
1. 内聚：模块内部各个成分之间的联系，也称为块内联系或块内强度
低内聚：
* 偶然性：功能上是互不相关
* 逻辑性：相关相似功能组合，每次调用时，传递给模块的参数来决定该模块应该有哪些部分完成
* 时间性：所包含的任务必须在同一时间内完成
中内聚：
* 过程性：必须按照某一特定的次序执行
* 通信性：各个成份都是用同一种输入数据，产生同一个输出数据
高内聚：
* 顺序性：处理必须顺序执行，一个处理元素的输出数据作为下一个处理元素的输入数据
* 功能性：所有成分结合，用于完成一个单一的功能

2. 耦合：一个模块与其他模块之间的联系，耦合性越高独立性越弱
从低到高的耦合性如下：
* 非直接耦合：没有直接联系，它们之间的联系完全是通过主模块的控制和调用来实现的
* 数据耦合：模块访问另一个模块，彼此间是通过简单数据参数来交换输入、输出信息的，比如计算电费和计算水费两个模块，一个模块输入用电量，一个输入用水量
* 标记耦合：通过参数表传递记录信息，比如共享了某个数据结构的子结构，比如计算电费和计算水费两个模块，两个都输入用户情况
* 控制耦合：一个模块通过比如`flag`这样的开关、标志、名字等控制信息来控制另一个模块
* 外部耦合：两个模块同时访问一个公共变量
* 公共耦合：访问一个公共数据环境
	* 松散的：一个只是修改，一个只是读取
	* 紧密的：两个都可以修改和读取
* 内容耦合：出现如下情况者
1. 一个模块直接访问另一个模块的内部数据
2. 一个模块可以通过不正常的入口转到另一个模块的内部
3. 两个模块的部分代码重复
4. 一个模块有多个入口

软件开发追求的是：高内聚低耦合：内部紧密联系、外部相对独立

#### 模块独立性意义:
1. 尽可能追求高内聚和低耦合的系统
2. 将对这类系统中任一模块的设计、测试和维护相对独立
3. 由于模块间联系较少，错误在模块间传播的可能性也随之变小
4. 模块间的耦合程度直接影响系统的可理解性、可测试性、可靠性和可维护性

3. 抽象Abstraction：忽略细节，分层理解问题，自顶向下层层细化，包括对过程、数据和控制的抽象。

4. 信息隐蔽：在设计和确定模块时，使得一个模块内包含的信息（过程和数据）对于不需要这些信息的模块来说，是不可访问的。

### 结构化设计的主要内容
* 概要设计：主要任务是将数据流图映射为软件系统结构图

* 详细设计：对概要设计的每一个模块进行数据设计和过程设计；也是对软件结构中的每一个模块确定使用的算法或块内数据结构，并用某种选定的表达工具给出清晰的描述。
主要表达工具：程序流程图、盒图、PAD、PDL、IPO

####  两种数据流类型：
* 事务型：数据沿输入通路到达一个加工T，这个加工根据输入数据的类型在若干个动作序列中选出一个来执行
* 变换型：变换分析是一系列设计步骤的总称，经过这些步骤把具有变换流特点的数据流图映射成为一个预定义的程序结构模板。

#### 模块分解中的启发式规则：
* 改进软件结构以提高模块独立性
* 模块的大小要适当
* 深度、宽度、扇出和扇入都应适当
* 模块的作用域应在控制域之内
* 力争降低模块接口的复杂程度
* 设计单入口单出口的模块
* 模块功能应该可预测，避免对模块施加过多限制

### 小结:
* 软件设计的基本目的是解决“系统应该如何实现”这个问题
* 模块化和模块独立性
* 结构化设计主要解决如何将需求分析阶段的DFD 图推导为软件系统结构，并用它提供的结构图描述之。
* 系统设计时要遵循模块化、自顶向下逐步求精的基本思想。
* 详细设计着重对各个模块的逻辑进行详细设计。

## 面向对象

定义：面向对象技术基于对象概念，以对象为中心，以类、组合、继承为构造机制，充分利用接口和多态提供灵活性，来认识、理解、刻画客观世界和设计、构建相应的软件系统
> 面向对象=对象 + 类 + 消息 + 继承 + 多态

> 对象：将客观世界的实体抽象为空间问题中的对象
> 类：把具有相同特征的行为和属性归在一起就形成了类
> 消息：实现对象类之间的通信和任务传递
> 封装：把对象属性和操作结合在一起，构成独立的单元，只能通过有限的接口于对象发生联系，不能直接存取对象的属性
> 多态性：子类对象可以像父类对象一样使用，同样的消息可以发给父类消息也可以发给子类

是一种把面向对象的思想运用于软件开发过程，指导开发活动的系统方法，包括分析、设计和实现等活动

优点：改善软件结构（模块化与封装），提高软件灵活性；增加可扩展性；支持增量式开发，支持大型软件开发

1. 建模：就是认识现实世界，模型是对现实世界的认识，是现实事物简化的对应物。
2. 可视化建模使用图形符号表示系统的业务流程，是一个沟通工具。

### UML
是对象管理 组织（OMG）制定的一个通用的、可视化的建模语言标准，可以用来可视化（visualize） 、描述（specify）、构造（construct）和文档化（document）软件密集型系统的各种工件（artifacts，又译制品）。
简述：统一建模语言，以面向对象图的方式来描述任何类型的系统模型。

UML事物：最具有代表性的成分的抽象
1. 类：具有相同属性、相同方法、相同语义和相同关系的一组对象的集合。
2. 接口：描述了一个类或构件的向外提供的操作集。
3. 协作：协作定义了交互的操作，表示一些角色和其他元素一起工作，提供一些合作的动作。一个给定的类可能是几个协作的组成部分，这些协作代表构成系统的模式的实现。
4. 用例：定义了系统执行的一组操作，对特定的用户产生可以观察的结果
5. 活动类：类对象有一个或多个线程或进程的类。
6. 组件：物理上可替换的，实现了一个或多个接口的系统元素。
7. 节点：是一个物理元素，它在运行时存在，代表一个可计算的资源，比如一台数据库服务器。在UML中，节点使用一个立方体来表示。节点通常包括处理器和设备。

UML行为事物：动作事物，是UML模型中的动态部分，代表时间和空间上的动作。
1. 交互：交互由在特定环境中共同完成一定任务的一组对象之间交换的消息组成
2. 状态机：状态机是对象的一个或多个状态的集合。

UML关系：
1. 关联（普通箭头）：关联是一种结构关系，它描述了一组对象之间的静态连接
2. 依赖（虚线箭头）：依赖是一种使用关系，它说明一个事物的变化可能影响到使用它的另一个事物。
> 聚合和组合：
> * 聚合（Aggregation，空心菱形箭头）是一种特殊形式的关联，它表示类之间的整体与部分的关系
> * 组合（Composition，实心菱形箭头）是一种特殊形式的聚集，组合关系中的整体与部分具有同样的生存期。

4. 泛化，空心箭头
5. 实现（空心虚线箭头）：类之间的语义关系，其中的一个类指定了由另一个类保证执行的契约。

### UML图

1. 功能
* **用例图：说明和定义软件系统的功能需求**
	* 参与者：可以使用户也可以是其他的外部系统和硬件设备
	* 用例
	* 关系
		* 泛化：空箭头
		* 包含：<<include>>
		* 扩展：<<extend>>

2. 静态结构：类之间关系：关系、依赖、聚合
**类图：类以及类之间的相互关系**
对象图：在某一时刻对象和他们的联系

3. 动态行为：
**顺序图：强调时间顺序的交互图**
协作图
状态图：一组状态、以及状态之间的转移
活动图：描述不同对象所执行的一组活动、以及活动之间的关系

> 时序图：序列图+顺序图

4. 物理架构
构件图：构件以及它们之间的关系
部署图：描述节点、以及节点和节点之间的关系，系统软件和硬件的物理配置情况和系统体系结构

### 用例建模过程
1. 描述模板
用例名称
用例编号
用例描述
参与者
前置条件
事件流
	基本路径
	可选路径
后置条件
其他

### 对象建模
建立系统的对象模型，反映了系统类与类的关系，体现了系统的静态结构

接口

识别分析类
1. 边界类：UI界面，对象交互
2. 控制类：系统行为，系统做什么协调各个边界类对象、实体类对象等
3. 实体类：描述必须存储的信息，描述相关的行为

UML视图：5种



面向对象分析方法

面向对象设计方法


详细设计：对象设计和对象持久化设计（数据库设计）
* 对象设计：着力于描述对象的内部细节
* 对象持久化设计：解决对象数据存储和检索，对象数据如何存储。


## 测试与维护基本概念

### 软件测试
测试过程：
1. 人工或者自动的运行系统查找系统中存在的问题：是否满足预期的需求、弄清系统预期的结果、目前系统与实际结果之间的差别

软件缺陷：
1. 功能不足
2. 有bug
3. 没有达到相应的目标
4. 操作复杂，不好操作
5. 实现了未提及的功能

#### 测试方法

先理清几个概念：
1. 黑盒：不调试直接运行获得结果
2. 白盒：调试程序的内部
3. 静态：只看代码
4. 动态：运行程序

数据测试：等价划分

状态测试：通过性测试和失效性测试

#### 白盒和黑盒

|白盒|黑盒
:--:|:--:|:--:
静态|审查代码（具体到变量）|检查说明书（高层次和低层次）
动态|数据覆盖和代码覆盖（语句覆盖、条件覆盖、分支覆盖）|验证程序的结果

## 设计模式
描述在我们周围不断重复发生的问题，以及该问题的解决方案，使用设计模式，就可以一次一次的利用已有的方案而不用做重复劳动

1. 设计模式的意义
答：优化的设计经验，极高的复用性（轮子），丰富的表达能力（轮子组合型高），极低的耦合度（轮子之间不冲突）

2. 设计模式的优点和有什么体会
答：方便，总结了前人的经验总结，描述了重复发生的问题以及对应的解决方案，减少了犯错率。


