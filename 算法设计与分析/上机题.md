【问题描述】正整数X的约数是能整除x的的正整数，正整数x的约数个数记为div(x)。例如，1、2、5、10都是正整数10的约数，且div(10)=4 。设a和b是2个正整数，a<=b，找出a和b之间约数个数最多的数x。
算法设计：对于给定的2个正整数a<=b（a,b的值不超过36），计算a和b之间约数个数最多的数。
【输入形式】输入数据第一行有2个正整数a和b。中间用#分开。
【输出形式】输出结果div(x)。
【样例输入】1#36
【样例输出】9

```cpp 关键代码
int f(int n)
{
    int counter = 2;
    for(int i=2;i<=n/2;i++)
        if(n%i==0)
            counter++;
    return counter;
}
```

公园5世纪，我国古代数学家张丘建在他所撰写的《算经》中，提出了这样的一个问题：“鸡翁一，值钱五；鸡母一，值钱三；鸡雏三，值钱一。百钱买百鸡，问鸡翁、母、雏各几何？”意思是共计每只5元，母鸡每只3元，小鸡每3只1元。用100元买100只鸡，求公鸡、母鸡、小鸡的只数。
【输出形式】输出结果形式：一个答案一行
【样例输出】
30 20 50
35 15 50
18 12 70
```cpp 
//5x+3y+z/3=100
//x+y+z=100
for (int x = 0; x <= n / 5; x++) {
		for (y = 0; y <= n / 3; y++) {
			z = n - y - x;
			if (z % 3 != 0) continue;
			if (5 * x + 3 * y + (z / 3) == n) {
				//输出结果
				num++;
			}
		}
	}
```


【问题描述】世界名画陈列馆由mxn个排列成矩形阵列的陈列室组成。为了防止名画被盗，需要在陈列室中设置警卫机器人哨位。每个警卫机器人除了件事它所在的陈列室外，还可以件事与它所在的陈列室相邻的上、下、左、右4个陈列室。试设计一个安排警卫机器人哨位的算法，使名画陈列馆中每一个陈列室都在警卫机器人的监视之下，且所用的警卫机器人数最少。
【算法设计】设计一个优先队列式分支限界法，计算警卫机器人的最佳哨位安排，是名画陈列馆中每一个陈列室都在警卫机器人的监视之下，且所用的警卫机器人最少。
【输入形式】第1行有2个正整数m和n(1<=m,n<=20)。中间用英文逗号隔开。
【输出形式】第1行是警卫机器人数；接下来的m行中每行n个数，0表示无哨位，1表示有哨位。中间用英文逗号隔开。如果输入的数据不符合要求或者计算结果有误，则输出"error"。注意：英文error即可。
【样例输入】
4,4
【样例输出】
4
0,0,1,0
1,0,0,0
0,0,0,1
0,1,0,0

【问题描述】设有n件工作分配给n个工人。将工作i分配给第j个人需要的费用为cij。试设计一个算法，为每个人都分配1件不同的工作，并是总费用达到最小。
【算法设计】设计一个算法，对于给定的工作费用，计算最佳工作分配方案，使总费用达到最小。
【输入形式】第1行有1个正整数n(1<=n<=20)。接下来的n行，每行n个数，表示工作费用。每行数字之间用逗号隔开（注意：英文逗号）
【输出形式】输出计算的最小总费用。注：如果输入数据错误或者计算结果错误，则输出“error”（注意：英文error即可）
【样例输入】
3
10,2,3
2,3,4
3,4,5
【样例输出】
9

```cpp 回溯法解决工作分配
int cost[N][N]; //各个工作的费用 cost[1][1]代表第二个工作分配给第二个人的费用（从0开始）
int a[N];//存储工作的索引，即工作分配给了谁
int n,cv;//总工作量和总费用
int bestv=INT_MAX;//初始化
void backtrack(int t)
{
        if(t>n)
        {//任务分配完毕
                if(cv<bestv)
                        bestv=cv;
                return;
        }
        else
        {
                for(int i=t;i<=n;i++)
                {//分配任务
                        cv+=cost[t][a[i]];
                        swap(a[t],a[i]);
                        if(cv < bestv)
                                backtrack(t+1);
                        swap(a[t],a[i]);
                        cv-= cost[t][a[i]];//回溯
                }
        }
}
```

【问题描述】用2台处理机A和B处理n个作业。设第i个作业交给机器A处理时需要时间ai，若有机器B处理，则需要时间bi。由于各作业的特点和机器的性能关系，很可能对于某些i，有ai>=bi而对于某些j，j≠i，有aj`<`bj。既不能将一个作业分开由2台机器处理，也没有一台机器能同时处理2个作业。设计一个动态规划算法，使得这2台机器处理完这n个作业的时间最短（从任何一台机器开工到最后一台机器停工的总时间）。研究一个实例：(a1,a2,a3,a4,a5,a6)=(2,5,7,10,5,2)；(b1,b2,b3,b4,b5,b6)=(3,8,4,11,3,4)。
【算法设计】对给定的2台处理机A和B处理n个作业，找出一个最优调度方案，使2台机器处理完这n个作业的时间最短。
【输入形式】第一行是1个正整数n，表示要处理n个作业。在接下来的2行中，每行有n个正整数，分别表示处理机A和B处理第i个作业需要的处理时间（每个数之间用英文逗号隔开）。
【输出形式】输出最短处理时间。如果给出的输入数据错误或者计算结果错误，则输出“error”（注：英文error即可）
【样例输入】
6
2,5,7,10,5,2
3,8,4,11,3,4
【样例输出】
15


【问题描述】设A和B是2个字符串。要用最少的字符串操作将字符串A转换为字符串B。这里所说的字符操作包括：（1）删除一个字符；（2）插入一个字符；（3）将一个字符改为另一个字符。
将字符串A变为字符串B所用的最少字符操作数称为字符串A到B的编辑距离，记为d(A,B)。试设计一个有效算法，对任给的2个字符串A和B，计算出他们的编辑距离d(A,B)。
【输入形式】第一行是字符串A，第二行是字符串B。
【输出形式】输出编辑距离d(A,B)。
【样例输入】
fxpimu
xwrs
【样例输出】
5
```cpp
int MinEditDistance(string A,string B)
{
    int len_A = A.length();
    int len_B = B.length();
    int D[len_B+1][len_A+1];
    D[0][0]=0;
    for(int i=1;i<=len_A;i++)
    {
        D[0][i]=i;
    }
    for(int i=1;i<=len_B;i++)
    {
        D[i][0]=i;
    }
    for(int i=1;i<=len_B;i++)
    {
        for(int j=1;j<=len_A;j++) //填表：1. 比较是否相等，如果相等就不动，不相等就+1并与上一次比较最小
            D[i][j]=min(min(D[i-1][j]+1,D[i][j-1]+1),(A[j-1]==B[i-1]?D[i-1][j-1]:D[i-1][j-1]+1));
    }
    return D[len_B][len_A];
 
}
```

【问题描述】给定一个自然数n，由n开始可以依次产生半数集set(n)中的数如下：
（1）n∈set(n);
（2）在n的左边加上一个自然数，但该自然数不能超过最近添加的数的一半；
（3）按此规则进行处理，直到不能再添加自然数为止。
例如，set(6)={6,16,26,126,36,136}。半数集set（6）中有6个元素。注意，该半数集是多重集。
【算法设计】对于给定的自然数n，计算半数集set(n)中的元素个数。
【输入形式】只有1行，给出整数n（0`<`n`<`1000）。
【输出形式】只有1行，给出半数集set(n)中的元素个数。
【样例输入】
6
【样例输出】
6

【问题描述】给定含有S个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如，S={1,2,2,2,3,5}。多重数S的众数是2，其重数为3 。
【算法设计】对于给定的由n个自然数组成的多重集S，计算S的众数及其重数。
【输入形式】第1行为多重数集S中元素个数n；接下来的n行中，每行有一个自然数。
【输出形式】输出文件有2行，第1行是众数，第2行是重数。
【样例输入】
6
1
2
2
2
3
5
【样例输出】
2
3

【问题描述】设有n个程序{1，2，....,n}要存放在长度为L 的磁带上。程序i存放在磁带上的长度是li (1≤i≤n)。程序存储问题要求确定这n个程序在磁带上的一个存储方案，使得能够在磁带上存储尽可能多的程序
【算法设计】对于给定的n个程序存放在磁带上的长度，计算磁带上最多可以存储的程序数。
【输入形式】第1行是2个正整数，分别表示文件个数n和磁带的长度L。接下来的1行中，有n个正整数，分别表示程序存放在磁带上的长度。
【输出形式】输出计算的最多可以存储的程序数。
【样例输入】
6 50
2 3 13 8 80 20
【样例输出】
5

【问题描述】假设要在足够多的会场里安排一批活动，并希望使用尽可能少的会场。设计一个有效的贪心算法进行安排。（这个问题实际上是著名的图着色问题。若将每个活动作为图的一个顶点，不相容活动间用边相连。使相邻顶点着有不同颜色的最小着色点，相当于要找的最小会场数。）
【算法设计】对于给定的K个待安排的活动，计算使用最少会场的时间表。
【输入形式】第1行有1个正整数k，表示有k个待安排的活动。接下来的k行中，每行有2个正整数，分别表示k个待安排的活动的开始时间和结束时间。时间以0开始的分钟计。。（注：每行数之间用一个空格隔开）
【输出形式】输出计算的最少会场数。
【样例输入】
5
1 23
12 28
25 35
27 80
36 50
【样例输出】
3

【问题描述】一辆虚拟汽车加满油后可行使n km。旅途中有若干个加油站。设计一个有效算法，指出应在哪些加油站停靠加油，使沿途加油次数是最少。并证明算法能产生一个最优解。
【算法设计】对于给定的n和k个加油站位置面积算最少加油次数。
【输入形式】第1行有2个正整数n和k，表示汽车加满油后可行驶n km，且旅途中有k个加油站。接下来的1行中有k+1个整数，表示第k个加油站与第k-1个加油站之间的距离。第0个加油站表示出发地，汽车已加满油。第k+1个加油站表示目的地。
【输出形式】输出计算的最少加油次数
【样例输入】
7 7
1 2 3 4 5 1 6 6
【样例输出】
4

【问题描述】在一台超级计算机上，编号为1，2，...，n的n个作业等待批处理。批处理的任务就是将这n个作业分成若干批，每批包含相邻的若干作业。从时刻0开始，分批加工这些作业。在每批作业开始前，机器需要启动时间S，而完成这批作业所需要的时间是单独完成批次中各个作业需要时间的总和。单独完成第i个作业所需要的时间是ti, 所需要的费用是它的完成时刻乘以一个费用系数fi。同一批作业将在同一时刻完成。例如，如果在时刻T开始一批作业x, x+1, ..., x+k, 则这一批作业的完成时刻均为T+S+(tx+tx+1+ ... +tx+k)。最优批处理问题就是要确定总费用最小的批处理方案。例如，假定5个作业等待批处理，且
S=1,   (t1, t2, t3, t4, t5)=(1, 3, 4, 2, 1),    (f1, f2, f3, f4, f5)=(3, 2, 3, 3, 4)
如果采用批处理方案{1, 2}, {3}, {4, 5}, 则各作业的完成时间分别为（5,5,10,14,14），各作业的费用分别为（15,10,30,42,56），因此，这个批处理方案总费用是153.
【算法设计】对于给定的待批处理的n个作业，计算其总费用最小的批处理方案。
【输入形式】第一行是待批处理的作业数n，第二行是启动时间S。接下来每行有2个数，分别为单独完成第i个作业所需要的时间ti和所需要的费用系数fi 。（每个数之间用空格分开）
【输出形式】输出计算出的最小总费用。
【样例输入】
5
1
1 3
3 2
4 3
2 3
1 4
【样例输出】
153

【问题描述】用两台处理机A和B处理n个作业。设第i个作业交给机器A处理时需要时间ai, 若由机器B处理，则需要时间bi 。由于各作业的特点和机器的性能关系，可能对于某些i，有ai>=bi，而对于某些j(j!=i，j不等于i)，有aj`<`bj。即不能将一个作业分开由两台机器处理，也没有一台机器能同时处理2个作业。设计一个动态规划算法，使得这两台机器处理完成这n个作业的时间最短（从任何一台机器开工到最后一台机器停工的总时间）。
研究一个实例：(a1, a2, a3, a4, a5, a6)=(2, 5, 7, 10, 5, 2), (b1, b2, b3, b4, b5, b6, )=(3, 8, 4, 11, 3, 4)
【算法设计】对于给定的两台处理机A和B处理n个作业，找出一个最优调度方案，使2台机器处理完成这n个作业的时间最短。（每个数之间用空格隔开）
【输入形式】第一行是1个正整数n，表示要处理n个作业。在接下来的2行中，每行有n个正整数，分别表示处理机A和B处理第i个作业需要的处理时间。
【输出形式】将最短处理时间输出。
【样例输入】
6
2 5 7 10 5 2
3 8 4 11 3 4
【样例输出】
15

【问题描述】对于长度相同的两个字符串A和B，其距离定义为相应位置字符距离之和。两个非空格字符的距离是它们的ASCII编码之差的绝对值。空格与空格的距离为0， 空格与其他字符的距离为一定值k。
在一般情况下，字符串A和B的长度不一定相同。字符串A的扩展是在A中插入若干空格字符所产生的字符串。在字符串A和B的所有长度相同的扩展中，有一对距离最小的扩展，该距离称为字符串A和B的扩展距离。
对于给定的字符串A和B， 试设计一个算法，计算其扩展距离。
【算法设计】对于给定的字符串A和B，计算其扩展距离。
【输入形式】第一行是字符串A，第二行是字符串B，第三行是空格与其他字符的距离定值k 。
【输出形式】输出计算出的字符串A和B的扩展距离。
【样例输入】
cmc
snmn
2
【样例输出】
10

【问题描述】现有n种不同形状的宝石，每种宝石有足够多颗。欲将这些宝石排列成m行n列的一个矩阵，m≤n，使矩阵中每行和每列的宝石都没有相同形状。试设计一个算法，计算出对于给定的m和n，有多少种不同的宝石排列方案。
【算法设计】对于给定的m和n，计算出不同的宝石排列方案数。
【输入形式】第1行有2个正整数m和n（0`<`m`≤`n`<`9）.
【输出形式】将计算的宝石排列方案输出。
【样例输入】
3  3
【样例输出】
12

【问题描述】假设有n个任务由k个可并行的机器来完成，完成任务i需要时间为ti。试设计一个算法，找出完成这n个任务的最佳调度，使得完成全部任务的时间最早。
【算法设计】对任意给定的整数n和k，以及完成任务i需要的时间为ti（i=1-n）。计算完成这n个任务的最佳调度。
【输入形式】第1行有2个正整数n和k。第2行的n个正整数是完成n个任务需要的时间。
【输出形式】将计算的全部任务的最早时间输出。
【样例输入】
7  3
2  14  4 16  6  5  3
【样例输出】
17


【问题描述】
子集和问题的一个实例为<S,t>。其中，S={x1，x2，…，xn}是一个正整数的集合，c是一个正整数。子集和问题判定是否存在S的一个子集S1，使得∑x∈S1  x=c。试设计一个解子集和问题的回溯法。
【算法设计】对于给定的正整数和集合S={x1，x2，...，xn}和正整数c，计算是S的一个子集S1，使得∑x∈S1  x=c。
【输入形式】文件第1行有2个正整数n和c，n表示S的大小，c是子集和的目标值。接下来的1行中，有n个正整数，表示集合S中的元素。
【输出形式】将子集和问题的解输出
【样例输入】
5  10
2  2  6  5  4
【样例输出】
2  2  6